#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           treadmill1,    tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           tlLauncher,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           trLauncher,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           brLauncher,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           blLauncher,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          treadmill2,    tmotorVex393TurboSpeed_HBridge, openLoop)

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Vex Motor Definitions
#define vexMotorMax 127
#define vexMotorMin -127
#define vexMotorOff 0

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller 
{
    long            counter;                

    // encoder tick per revolution
    float           ticks_per_rev;          

    // Encoder
    long            e_current;              
    long            e_last;                 

    // velocity measurement
    float           v_current;              
    long            v_time;                 

    // TBH control algorithm variables
    long            target;                 
    long            current;                
    long            last;                   
    float           error;                  
    float           last_error;             
    float           gain;                   
    float           drive;                  
    float           drive_at_zero;          
    long            first_cross;            
    float           drive_approx;           

    // final motor drive
    long            motor_drive;            
    } fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

void
FwMotorSet( int value )
{
	motor[tlLauncher] = value;
	motor[trLauncher] = value;
	motor[brLauncher] = value;
	motor[blLauncher] = value;
}

long
FwMotorEncoderGet()
{
    return( nMotorEncoder[ blLauncher ] );
}

void
FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
    // set target velocity (motor rpm)
    fw->target        = velocity;

    // Set error so zero crossing is correctly detected
    fw->error         = fw->target - fw->current;
    fw->last_error    = fw->error;

    // Set predicted open loop drive value
    fw->drive_approx  = predicted_drive;
    // Set flag to detect first zero crossing
    fw->first_cross   = 1;
    // clear tbh variable
    fw->drive_at_zero = 0;
}

void
FwCalculateSpeed( fw_controller *fw )
{
    int     delta_ms;
    int     delta_enc;

    // Get current encoder value
    fw->e_current = FwMotorEncoderGet();

    delta_ms   = nSysTime - fw->v_time;
    fw->v_time = nSysTime;

    // Change in encoder count
    delta_enc = (fw->e_current - fw->e_last);

    fw->e_last = fw->e_current;

    // Calculate velocity in rpm
    fw->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fw->ticks_per_rev;
}

void
FwControlUpdateVelocityTbh( fw_controller *fw )
{
    // calculate error in velocity
    // target is desired velocity
    // current is measured velocity
    fw->error = fw->target - fw->current;

    // Use Kp as gain
    fw->drive =  fw->drive + (fw->error * fw->gain);

    // Clip - we are only going forwards
    if( fw->drive > 1 )
          fw->drive = 1;
    if( fw->drive < 0 )
          fw->drive = 0;

    // Check for zero crossing
    if( sgn(fw->error) != sgn(fw->last_error) ) {

        // First zero crossing after a new set velocity command
        if( fw->first_cross ) {

            // Set drive to the open loop approximation
            fw->drive = fw->drive_approx;
            fw->first_cross = 0;
        }
        else
            fw->drive = 0.5 * ( fw->drive + fw->drive_at_zero );

        // Save this drive value in the "tbh" variable
        fw->drive_at_zero = fw->drive;
    }

    // Save last error
    fw->last_error = fw->error;
}

task
FwControlTask()
{
    fw_controller *fw = &flywheel;

    // Set the gain
    fw->gain = 0.00025;

    // Set the encoder ticks per revolution
    fw->ticks_per_rev = MOTOR_TPR_393S;

    while(true)
        {
        // debug counter
        fw->counter++;

        // Calculate velocity
        FwCalculateSpeed( fw );

        // Set current speed for the tbh calculation code
        fw->current = fw->v_current;

        // Do the velocity TBH calculations
        FwControlUpdateVelocityTbh( fw ) ;

        // Scale drive into the range the motors need
        fw->motor_drive  = (fw->drive * FW_MAX_POWER) + 0.5;

        // Final Limit of motor values - don't really need this
        if( fw->motor_drive >  127 ) fw->motor_drive =  127;
        if( fw->motor_drive < -127 ) fw->motor_drive = -127;

        // and finally set the motor control value
        FwMotorSet( fw->motor_drive );

        // Run at somewhere between 20 and 50mS
        wait1Msec( FW_LOOP_SPEED );
        }

}

// LCD Display Variables
int count = 0;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

// Dead Zone Variables
int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

// Struct to hold flywheel values
typedef struct{
	float TargetSpeed;
	float CurrentSpeed;
} treadmill;
treadmill feed;

// Function to update Flywheel Speed
void UpdateTreadmillSpeed()
{
	feed.CurrentSpeed = feed.TargetSpeed;
	motor[treadmill1] = feed.CurrentSpeed;
	motor[treadmill2] = feed.CurrentSpeed;
}

// Creates a deadzone for your motors
void deadZoneCheck()
{

	//Create "deadzone" for Y1/Ch3
	if(abs(vexRT[Ch1]) > threshold)
		Y1 = vexRT[Ch1];
	else
		Y1 = 0;
	//Create "deadzone" for X1/Ch1
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	//Create "deadzone" for X2/Ch4
	if(abs(vexRT[Ch3]) > threshold)
		X2 = vexRT[Ch3];
	else
		X2 = 0;
}

// Converts a Decimal to Motor Speed
float percentToMotorSpeed( float percentInDecimal )
{
	return( percentInDecimal * vexMotorMax );
}

//~~~ auton methods~~~//

// Stops the motors associated with the flywheel
void fw_stop()
{
	motor[tlLauncher] = vexMotorOff;
	motor[trLauncher] = vexMotorOff;
	motor[brLauncher] = vexMotorOff;
	motor[blLauncher] = vexMotorOff;
}

// Sets the speed based on a decimal percentage you input
void fw_setSpeed( int percentageSpeedInDecimal ) //Because you wan to use percentage??
{
	float speed;
	speed = percentToMotorSpeed( percentageSpeedInDecimal );
	motor[tlLauncher] = speed;
	motor[trLauncher] = speed;
	motor[brLauncher] = speed;
	motor[blLauncher] = speed;
}

// Sets the TreadMill Speed
void fw_treadmill(int speed = 127)
{
	motor[treadmill1] = feed.CurrentSpeed;
	motor[treadmill2] = feed.CurrentSpeed;
}

//~~~ auton methods~~~//

task Drive
{
	while(true)
	{
		deadZoneCheck();

		// Remote Control Commands
		motor[frontLeft] = Y1  -X2  -X1;
		motor[frontRight]= Y1  +X2  -X1;
		motor[backLeft]  = Y1  -X2  +X1;
		motor[backRight] = Y1  +X2  +X1;
		
		// dont hog CPU
		wait1Msec(30);
	}
}

// waits for a LCD button to be pressed
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

// waits for a LCD button to be released
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

// Shows the battery of the Primary and Backup Batterys
string mainBattery, backupBattery;
void showBatteryLevel()
{
	bLCDBacklight = true;
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
	displayNextLCDString(mainBattery);

	displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');
	displayNextLCDString(backupBattery);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.

	bStopTasksBetweenModes = false;

	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	
	while(nLCDButtons != centerButton)
	{
		switch(count){
		case 0:

			displayLCDCenteredString(0, "4 Ball Launch");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();


			if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 1:
			displayLCDCenteredString(0, "2");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 2:
			displayLCDCenteredString(0, "3");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

		case 3:
			displayLCDCenteredString(0, "4");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 4:
			displayLCDCenteredString(0, "5");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 5:
			displayLCDCenteredString(0, "6");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 6:
			displayLCDCenteredString(0, "7");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

			showBatteryLevel();

			wait1Msec(100);

			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;

		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	switch(count){

	case 0:
		displayLCDCenteredString(0, "4 Ball Launch");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		fw_setSpeed(0.62);//startup
		wait1Msec(3000);
		fw_stop();

		fw_setSpeed(0.62);//launch ball 1
		fw_treadmill();
		wait1Msec(500);
		fw_stop();

		fw_setSpeed(0.62);//cooldown
		wait1Msec(3000);
		fw_stop();

		fw_setSpeed(0.62);//launch ball 2
		fw_treadmill();
		wait1Msec(500);
		fw_stop();

		fw_setSpeed(0.62);//cooldown
		wait1Msec(3000);
		fw_stop();

		fw_setSpeed(0.62);//launch ball 3
		fw_treadmill();
		wait1Msec(500);
		fw_stop();

		fw_setSpeed(0.62);//cooldown
		wait1Msec(3000);
		fw_stop();

		fw_setSpeed(0.62);//launch ball 4
		fw_treadmill();
		wait1Msec(500);
		fw_stop();

		break;

	case 1:
		displayLCDCenteredString(0, "2");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 2:
		displayLCDCenteredString(0, "Nonpin (3)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 3:
		displayLCDCenteredString(0, "Blue Nonpin (6)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 4:
		displayLCDCenteredString(0, "Red Nonpin (6)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 5:
		displayLCDCenteredString(0, "NOTHING YET");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 6:
		displayLCDCenteredString(0, "NOTHING YET");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;


	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;

	}
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

int fw_count;

void waitForReleaseSpeedButton()
{
	if(vexRT[Btn8L] == 0)
	{
		fw_count = 0;
	}
}

task usercontrol()
{
	
	// Start the drive task to let you drive! with included deadzone :)
	startTask( Drive );

  	bLCDBacklight = true;

  	// Start the flywheel task
  	startTask( FwControlTask );

	while (true)
	{

	showBatteryLevel();
		
	// Ajust Flywheel target velocity
    if( vexRT[ Btn8U ] == 1 ) {
       FwVelocitySet( &flywheel, 72, 0.38 );
    }
    if( vexRT[ Btn8D ] == 1 ) {
       FwVelocitySet( &flywheel, 00, 0 );
	}
    if( vexRT[ Btn8L ] == 1 && fw_count <= 9) {
       FwVelocitySet( &flywheel, 144, 0.55 );
       fw_count++;
    }

    if(fw_count == 9)
    { 
    	waitForReleaseSpeedButton(); 
    	FwVelocitySet( &flywheel, 72, 0.38 );
    }

	// Feed Control
	if(vexRT[Btn6U] == 1)						// if button is Pressed
	{
		feed.TargetSpeed = 127;
	}
	else										// Otherwise
	{
		feed.TargetSpeed = vexMotorOff;
	}
	
	UpdateTreadmillSpeed();
	
	// dont hog CPU
	wait1Msec(20);

	}
}
