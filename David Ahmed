//okay John, thank you for helping me
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           treadmill1,    tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           tlLauncher,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           trLauncher,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           brLauncher,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           blLauncher,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          treadmill2,    tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
//lcd variables//

int count = 0;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//~~~ auton methods~~~//

void stop() //To be used in autonomous to stop motors
{
	motor[0] = 0;
	motor[1] = 0;
	motor[2] = 0;
	motor[3] = 0;
	motor[4] = 0;
	motor[5] = 0;
	motor[6] = 0;
	motor[7] = 0;
	motor[8] = 0;
	motor[9] = 0;
}

void fly65() //flywheel 65% power
{
	motor[tlLauncher] = 72;
	motor[trLauncher] = 72;
	motor[brLauncher] = 72;
	motor[blLauncher] = 72;
}

void treadmill()
{
	motor[treadmill1] = 127;
	motor[treadmill2] = 127;
}

//~~~ auton methods~~~//

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

string mainBattery, backupBattery;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	clearLCDLine(0);
	clearLCDLine(1);
	while(nLCDButtons != centerButton)
	{
		bLCDBacklight = true;
		switch(count){
		case 0:

			displayLCDCenteredString(0, "4 Ball Launch");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();


			if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 1:
			displayLCDCenteredString(0, "2");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 2:
			displayLCDCenteredString(0, "3");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

		case 3:
			displayLCDCenteredString(0, "4");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 4:
			displayLCDCenteredString(0, "5");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 5:
			displayLCDCenteredString(0, "6");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;

		case 6:
			displayLCDCenteredString(0, "7");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}

			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;



			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
			displayNextLCDString(mainBattery);

			displayLCDString(1, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');
			displayNextLCDString(backupBattery);

			wait1Msec(100);

			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;

		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	switch(count){

	case 0:
		displayLCDCenteredString(0, "4 Ball Launch");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		fly65();//startup
		wait1Msec(3000);
		stop();

		fly65();//launch ball 1
		treadmill();
		wait1Msec(500);
		stop();

		fly65();//cooldown
		wait1Msec(3000);
		stop();

		fly65();//launch ball 2
		treadmill();
		wait1Msec(500);
		stop();

		fly65();//cooldown
		wait1Msec(3000);
		stop();

		fly65();//launch ball 3
		treadmill();
		wait1Msec(500);
		stop();

		fly65();//cooldown
		wait1Msec(3000);
		stop();

		fly65();//launch ball 4
		treadmill();
		wait1Msec(500);
		stop();

		break;

	case 1:
		displayLCDCenteredString(0, "2");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 2:
		displayLCDCenteredString(0, "Nonpin (3)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 3:
		displayLCDCenteredString(0, "Blue Nonpin (6)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 4:
		displayLCDCenteredString(0, "Red Nonpin (6)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 5:
		displayLCDCenteredString(0, "NOTHING YET");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;

	case 6:
		displayLCDCenteredString(0, "NOTHING YET");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(500);
		//autonomous goes here

		break;


	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;

	}
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
	//Usercontrol variables//
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
	bool on65 = false;
	bool on47 = false;
	//Usercontrol variables//

	while (true)
	{
		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.

		// .....................................................................................
		// Insert user code here. This is where you use the joystick values to update your motors, etc.
		bLCDBacklight = true;
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
		displayNextLCDString(mainBattery);

		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');
		displayNextLCDString(backupBattery);
		// .....................................................................................
		if(vexRT[Btn8L])
		{
			on65 = true;
		}
		if(vexRT[Btn8D])
		{
			on65 = false;
		}
		if(vexRT[Btn8U])
		{
			on47 = true;
		}
		if(vexRT[Btn8R])
		{
			on47 = false;
		}
		//~~~Boolean if statements~~~//

		if(on65)
		{
			while(on65)
			{
				if(vexRT[Btn8D] || vexRT[Btn8R])
				{
					on65 = false;
					motor[tlLauncher] = 0;
					motor[trLauncher] = 0;
					motor[blLauncher] = 0;
					motor[brLauncher] = 0;
					break;
				}
				motor[tlLauncher] = 72;
				motor[trLauncher] = 72;
				motor[blLauncher] = 72;
				motor[brLauncher] = 72;

				//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
				//Create "deadzone" for Y1/Ch3
				if(abs(vexRT[Ch1]) > threshold)
					Y1 = vexRT[Ch1];
				else
					Y1 = 0;
				//Create "deadzone" for X1/Ch1
				if(abs(vexRT[Ch4]) > threshold)
					X1 = vexRT[Ch4];
				else
					X1 = 0;
				//Create "deadzone" for X2/Ch4
				if(abs(vexRT[Ch3]) > threshold)
					X2 = vexRT[Ch3];
				else
					X2 = 0;


				//Remote Control Commands
				motor[frontLeft] = Y1  -X2  -X1;
				motor[frontRight]= Y1  +X2  -X1;
				motor[backLeft]  = Y1  -X2  +X1;
				motor[backRight] = Y1  +X2  +X1;

				motor[port1] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);
				motor[port10] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);

			}
		}
//~~~end if statements for 65% power~~~//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//~~~start if statements for 47% power~~~//

			if(on47)
		{
			while(on47)
			{
				if(vexRT[Btn8D] || vexRT[Btn8R])
				{
					on65 = false;
					motor[tlLauncher] = 0;
					motor[trLauncher] = 0;
					motor[blLauncher] = 0;
					motor[brLauncher] = 0;
					break;
				}
				motor[tlLauncher] = 59;
				motor[trLauncher] = 59;
				motor[blLauncher] = 59;
				motor[brLauncher] = 59;

				//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
				//Create "deadzone" for Y1/Ch3
				if(abs(vexRT[Ch1]) > threshold)
					Y1 = vexRT[Ch1];
				else
					Y1 = 0;
				//Create "deadzone" for X1/Ch1
				if(abs(vexRT[Ch4]) > threshold)
					X1 = vexRT[Ch4];
				else
					X1 = 0;
				//Create "deadzone" for X2/Ch4
				if(abs(vexRT[Ch3]) > threshold)
					X2 = vexRT[Ch3];
				else
					X2 = 0;


				//Remote Control Commands
				motor[frontLeft] = Y1  -X2  -X1;
				motor[frontRight]= Y1  +X2  -X1;
				motor[backLeft]  = Y1  -X2  +X1;
				motor[backRight] = Y1  +X2  +X1;

				motor[port1] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);
				motor[port10] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);

			}
		}
//~~~end if statements for 47% power~~~//
			//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
				//Create "deadzone" for Y1/Ch3
				if(abs(vexRT[Ch1]) > threshold)
					Y1 = vexRT[Ch1];
				else
					Y1 = 0;
				//Create "deadzone" for X1/Ch1
				if(abs(vexRT[Ch4]) > threshold)
					X1 = vexRT[Ch4];
				else
					X1 = 0;
				//Create "deadzone" for X2/Ch4
				if(abs(vexRT[Ch3]) > threshold)
					X2 = vexRT[Ch3];
				else
					X2 = 0;


				//Remote Control Commands
				motor[frontLeft] = Y1  -X2  -X1;
				motor[frontRight]= Y1  +X2  -X1;
				motor[backLeft]  = Y1  -X2  +X1;
				motor[backRight] = Y1  +X2  +X1;

				motor[port1] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);
				motor[port10] = (vexRT(Btn6U) * 127) + (vexRT(Btn6D) * -127);
				motor[port6] = (vexRT(Btn6U) * 127);

	}
}

// again thank you
